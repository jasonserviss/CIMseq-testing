---
title: "Validation of synthetic data algorithm"
author: "Jason T. Serviss"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r, message = FALSE}
packages <- c(
  "sp.scRNAseq",
  "sp.scRNAseqData",
  "sp.scRNAseqTesting",
  "seqTools",
  "printr",
  "ggthemes",
  "tidyverse"
)
purrr::walk(packages, library, character.only = TRUE)
rm(packages)
```

```{r}
#cpm normalization withoit adding 1 that works on both matrices and tibbles with
#genes as rows and cells as columns
norm <- function(counts) {
  if(all(class(counts) == c("tbl_df", "tbl", "data.frame"))) {
    mat <- counts %>% 
      as.data.frame() %>%
      column_to_rownames("gene") %>%
      as.matrix()
    
    t(t(mat) / colSums(mat) * 10^6) %>%
      matrix_to_tibble("gene")
  } else if(class(counts) == "matrix") {
    t(t(counts) / colSums(counts) * 10^6)
  }
}
```

### Algorithm 

```{r}
syntheticMultipletsFromCounts2 <- function(
  counts,
  classes,
  combos,
  adjustment,
  seed = 87909023,
  ...
){
  set.seed(seed)
  
  #setup output structure
  output <- data.frame(gene = rownames(counts), stringsAsFactors = FALSE)
  
  combos %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  #for each combination in combos...
  map(., function(x) {
    #the x variable is a character vector including the names of the cell types
    # to be included in the multiplet
    
    #select one cell from the pool for each cell type
    exCounts <- counts[, map_int(x, ~sample(which(classes == .x), 1))]
    colnames(exCounts) <- x
    
    #adjust the counts by multiplying with the corresponding values in the
    # adjustment variable provided as an arg
    adj <- adjustment[match(x, names(adjustment))]
    adjusted <- round(t(t(exCounts) * adj))
    
    #calculate the sum of counts for each gene
    rs <- rowSums(adjusted)
    
    #Sample from the poisson distribution for each gene with lambda = rs[i]
    map_dbl(1:nrow(exCounts), function(i) {
      rpois(n = 1, lambda = rs[i])
    }) %>%
      as.data.frame(stringsAsFactors = FALSE) %>%
      add_column(gene = rownames(exCounts), .before = 1) %>%
      setNames(c("gene", paste(sort(x), collapse = "-")))
  }) %>%
  #reformat as tibble for easy integration with output from other function calls
  reduce(full_join, by = "gene") %>%
  full_join(output, by = "gene") %>%
  replace(is.na(.), 0) %>%
  as_tibble()
}

```

```{r}
s <- str_detect(colnames(countsMgfp), "^s")
commonGenes <- intersect(rownames(countsMgfp), rownames(countsRegev))

sng <- cbind(countsMgfp[commonGenes, s], countsRegev[commonGenes, ])
mul <- countsMgfp[commonGenes, !s]

erccSng <- cbind(
  countsMgfpERCC[, s], 
  matrix(NA, nrow = nrow(countsMgfpERCC), ncol = ncol(countsRegev))
)
erccMul <- cbind(countsMgfpERCC[, !s])

boolMulC <- colnames(mul) %in% filter(countsMgfpMeta, tissue == "colon")$sample
boolSngC <- colnames(sng) %in% filter(countsMgfpMeta, tissue == "colon")$sample

#setup spCounts
cObjSng <- spCounts(sng, erccSng)
cObjMul <- spCounts(mul, erccMul)

#spUnsupervised
uObj <- spUnsupervised(cObjSng, seed = 2334, max_iter = 3000, max = 2000)
plotUnsupervisedClass(uObj, cObjSng) %>%
  plotData() %>%
  mutate(Regev = if_else(str_detect(Sample, "SRR"), TRUE, FALSE)) %>%
  ggplot() +
  geom_point(
    aes(
      `t-SNE dim 1`, `t-SNE dim 2`, 
      colour = Classification, shape = Regev
    )
  ) + 
  geom_label(
    data = getData(uObj, "tsneMeans"),
    aes(x = x, y = y, label = classification)
  )
```

Synthesize Multiplets
```{r}
tidyUnsupervised(uObj) %>%
  filter(Classification %in% c("B1", "K1", "R1", "Z1", "T1", "Q1")) %>%
  mutate(type = case_when(
    Classification %in% c("B1", "K1") ~ "Colon.Stem",
    Classification %in% c("R1", "Z1", "T1", "Q1") ~ "SI.Stem",
    TRUE ~ Classification
  )) %>%
  mutate(Regev = if_else(str_detect(Sample, "SRR"), TRUE, FALSE)) %>%
  count(Regev, type)

classes <- getData(uObj, "classification")

bool1 <- classes %in% c("B1", "K1", "R1", "Z1", "T1", "Q1")
bool2 <- colnames(getData(cObjSng, "counts")) %in% countsMgfpMeta$sample
bool <- bool1 & bool2
combos <- apply(combn(unique(classes[bool]), 2), 2, sort)
adjustment <- rep(1, length(unique(classes[bool])))
names(adjustment) <- unique(classes[bool])

n <- 100
names <- paste(
  apply(combos, 2, paste, collapse = "-"), 
  rep(1:n, each = ncol(combos)), 
  sep = "."
)

synth <- rbind(getData(cObjSng, "counts")[, bool], getData(cObjSng, "counts.ercc")[, bool]) %>%
  norm() %>%
  {map(1:n, function(x) {
    syntheticMultipletsFromCounts2(., classes[bool], combos, adjustment, seed = x + 9789)
  })} %>%
  reduce(full_join, by = "gene") %>%
  setNames(c("gene", names)) %>%
  as.data.frame() %>%
  column_to_rownames("gene") %>%
  as.matrix()

synth.counts <- synth[!grepl("^ERCC\\-[0-9]*$", rownames(synth)), ]
synth.ercc <- synth[grepl("^ERCC\\-[0-9]*$", rownames(synth)), ]

cObjSynth <- spCounts(synth.counts, synth.ercc)
```

Swarm
```{r}
cn <- estimateCells(cObjSng, cObjSynth)
sObj <- spSwarm(cObjSynth, uObj, distFun = "dtsnCellNum", e = 0.0025, cellNumbers = cn)
```

