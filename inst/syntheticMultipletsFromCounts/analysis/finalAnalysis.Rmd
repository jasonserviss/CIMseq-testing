---
title: "Validation of synthetic data algorithm"
author: "Jason T. Serviss"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r, message = FALSE}
#PACKAGES
packages <- c(
  "sp.scRNAseq","sp.scRNAseqData", "sp.scRNAseqTesting",
  "seqTools", "printr", "ggthemes", "tidyverse"
)
purrr::walk(packages, library, character.only = TRUE)
rm(packages)

#FUNCTIONS
#cpm normalization withoit adding 1 that works on both matrices and tibbles with
#genes as rows and cells as columns
norm <- function(counts) {
  if(all(class(counts) == c("tbl_df", "tbl", "data.frame"))) {
    mat <- counts %>% 
      as.data.frame() %>%
      column_to_rownames("gene") %>%
      as.matrix()
    
    t(t(mat) / colSums(mat) * 10^6) %>%
      matrix_to_tibble("gene")
  } else if(class(counts) == "matrix") {
    t(t(counts) / colSums(counts) * 10^6)
  }
}
```

The deconvolution algorithm requires the synthesis of synthetic multiplets where
the fractions of individual contribution of cells in the multiplet is 
dynamically adjusted. These synthetic multiplets, with a known composition, are
subsequently compared to real multiplets allowing the deduction of their 
composition and, thus, the cell-cell connections they contain. 

The success of this process depends on our ability to accurately synthesize 
multiplets from singlets and adjust the input from the individual cell types.
In this analysis we test our multiplet synthesis algorithm finding that it is 
capable of achieving both of these goals.

The algorithm for generating the synthetic multiplets works as follows: The sum 
of normalized counts (counts per million) is calculated for each gene in two 
randomly selected singlets from each cell type contributing to the multiplet. 
The fraction of input into the multiplet can be adjusted so that, e.g. cell type 
_A_ only contributes half of what cell type _B_ contributes to the multiplet. 
The sum of adjusted counts for each gene is then calculated after which a 
random value is drawn from the Poisson distribution for each gene with lambda
equal to the adjusted count values.

Here we utilize the sorted cell line dataset to generate synthetic multiplets.
The synthetic multiplets are then compared to the real multiplets to ascertain 
the quality of the _in silico_ synthesis.

### Distribution of real vs synthetic multiplets..

There are 3 possible duplicate combinations in this dataset; A375-HCT116, 
A375-HOS, and HCT116-HOS. We begin by synthesizing 10 synthetic multiplets for 
each possible combination and examine the distribution of gene expression values
compared to the sorted multiplets.

```{r, fig.align="center", fig.width=10, fig.height=8, message = FALSE}
s <- str_detect(colnames(countsSorted2), "^s")
sng <- countsSorted2[, s]
classes <- slice(countsSortedMeta2, match(colnames(sng), countsSortedMeta2$sample))$cellTypes
combos <- apply(combn(unique(classes), 2), 2, sort)
adjustment <- rep(1, length(unique(classes)))
names(adjustment) <- unique(classes)

n <- 10
names <- paste(
  apply(combos, 2, paste, collapse = "-"), 
  rep(1:n, each = ncol(combos)), 
  sep = "."
)

#synthesize multiplets
synth <- sng %>%
  norm() %>%
  {map(1:n, function(x) {
    syntheticMultipletsFromCounts(., classes, combos, adjustment, seed = x + 9789)
  })} %>%
  reduce(full_join, by = "gene") %>%
  setNames(c("gene", names)) %>%
  norm()

#get real multiplet data
mul <- countsSorted2[, !s] %>%
  norm() %>%
  matrix_to_tibble("gene") %>%
  gather(sample, counts, -gene) %>%
  left_join(countsSortedMeta2, by = "sample") %>%
  select(gene, counts, cellTypes, sample)

#plot real and synthetic distributions
p1 <- synth %>% 
  gather(typeRep, synCounts, -gene) %>%
  separate(typeRep, c("cellTypes", "sample"), sep = "\\.") %>%
  inner_join(., mul, by = c("gene", "cellTypes")) %>% 
  gather(type, counts, -(gene:sample.x), -sample.y) %>%
  mutate(counts = log2(counts + 1)) %>%
  mutate(type = if_else(
    type == "counts", 
    "Real multiplets", 
    "Synthetic multiplets"
  )) %>%
  ggplot() + 
  geom_histogram(
    aes(counts, stat(ndensity), fill = type), 
    alpha = 0.5, binwidth = 0.25, position = "identity"
  ) +
  facet_wrap(~cellTypes) + 
  labs(
    x = "log2(cpm + 1)", y = "Density", tag = "A)",
    caption = paste0(
      "Histograms of gene expression in 10 synthetic multiplets ", 
      "(red) and 10 sorted multiplets (blue) in three different multiplet ",
      "types. y-axis (Density) scaled to [0, 1]."
    )
  ) +
  theme_bw() +
  ggthemes::scale_fill_ptol() +
  guides(fill = guide_legend(title = "")) +
  theme(legend.position = "top", plot.caption = element_text(hjust = 0))

p1

ggsave(
  plot = p1,
  filename = '../figures/figure1.pdf',
  device = cairo_pdf,
  height = 180,
  width = 240,
  units = "mm"
)
```

The results indicate a strong similarity in the distributions of the sorted and
synthesized multiplets. There is some disparity in the lower non-dropout reads 
but dropouts themselves and more highly expressed genes have nearly identical 
distributions. Overall, the results indicate that synthetic multiplets largely 
mirror real multiplets.

<br></br>

### Adjusting multiplet contribution

Next, we synthesized 25 synthetic multiplets and adjusted the contribution of 
HOS cells. To help visualize the results we first identified 25 genes that were 
highly specific for each cell type. We then visualize the mean expression of 
these genes in several subsets; sorted multiplets, non-adjusted synthetic 
multiplets, adjusted multiplets with multiple levels of adjustment, and 
singlets.

```{r}
###FUNCTIONS
#function to calculate the mean gene expression for a specific cell type. Used 
#previous to heatmap plotting
typeMeans <- function(type) {
  countsSortedMeta2 %>%
  filter(cellTypes == type) %>% 
  pull(sample) %>%
  {countsSorted2[, colnames(countsSorted2) %in% .]} %>%
  norm() %>%
  rowMeans() %>%
  matrix_to_tibble("gene") %>%
  setNames(c("gene", "counts")) %>%
  mutate(cellType = type)
}

#wrapper to generate and reformat multiplets
generateAdjustedMultiplets <- function(sng, classes, combos, adjustment, name) {
  q.name <- enquo(name)
  sng %>%
    norm() %>%
    {map(1:n, function(x) {
      syntheticMultipletsFromCounts(., classes, combos, adjustment, seed = x + 9789)
    })} %>%
    reduce(full_join, by = "gene") %>%
    setNames(c("gene", names)) %>%
    norm() %>%
    gather(cellTypes, !!q.name, -gene) %>%
    mutate(cellTypes = str_replace(cellTypes, "(.*)\\..*", "\\1")) %>%
    group_by(gene, cellTypes) %>%
    summarize(!! quo_name(q.name) := mean(!!q.name)) %>%
    ungroup()
}
###

#Synthesize multiplets with varying levels of adjusted HOS input
s <- str_detect(colnames(countsSorted2), "^s")
sng <- countsSorted2[, s]
classes <- slice(countsSortedMeta2, match(colnames(sng), countsSortedMeta2$sample))$cellTypes
combos <- apply(combn(unique(classes), 2), 2, sort)

adjustment <- rep(1, length(unique(classes)))
names(adjustment) <- unique(classes)
n <- 25
names <- paste(
  apply(combos, 2, paste, collapse = "-"), 
  rep(1:n, each = ncol(combos)), 
  sep = "."
)

adj <- c(1, 0.75, 0.5, 0.25, 0.01)
synth <- map(adj, function(x) {
  adjustment[names(adjustment) == "HOS"] <- x
  generateAdjustedMultiplets(sng, classes, combos, adjustment, synCounts)
}) %>%
  reduce(inner_join, by = c("gene", "cellTypes")) %>%
  setNames(c("gene", "cellTypes", paste0("HOS reduced ", (1 - adj) * 100, "%")))

#find overexpressed genes in each cell type
genes <- foldChangePerClass(cpm(sng), rename(countsSortedMeta2, class = cellTypes)) %>%
  matrix_to_tibble("gene") %>%
  select(gene, A375, HCT116, HOS) %>%
  gather(cellType, fold, -gene) %>%
  group_by(cellType) %>%
  top_n(25, fold) %>%
  ungroup()

#calculate the mean gene expression for each type of singlet
realSng <- map_dfr(c("A375", "HCT116", "HOS"), typeMeans)

#calculate the mean gene expression for each type of multiplet
#concatenate real singlet, real multiplet, and info for genes corresponding to 
#a cell type

real <- map_dfr(c("A375-HCT116", "A375-HOS", "HCT116-HOS"), typeMeans) %>%
  rename(Multiplet = counts, cellTypes = cellType) %>% 
  separate(cellTypes, into = c("cellType1", "cellType2"), sep = "-", remove = FALSE) %>%
  inner_join(realSng, by = c("cellType1" = "cellType", "gene" = "gene")) %>% 
  inner_join(realSng, by = c("cellType2" = "cellType", "gene" = "gene")) %>%
  inner_join(genes, by = "gene") %>%
  filter(cellType == cellType1 | cellType == cellType2) %>%
  rename(geneType = cellType)
```

```{r, eval = FALSE}
#join everything and plot
real %>% 
  inner_join(synth, by = c("gene", "cellTypes")) %>%
  gather(type, cpm, -gene, -(geneType:fold), -(cellTypes:cellType2)) %>%
  mutate(type = case_when(
    type == "counts.x" ~ cellType1, 
    type == "counts.y" ~ cellType2, 
    TRUE ~ type
  )) %>%
  mutate(type = parse_factor(type, levels = c(
      "Multiplet", "HOS reduced 0%", "HOS reduced 25%", "HOS reduced 50%", "HOS reduced 75%", "HOS reduced 99%", "A375", "HCT116", "HOS"
  ))) %>%
  arrange(geneType, fold) %>%
  mutate(plotGene = paste0(gene, " (", geneType, ")")) %>%
  mutate(plotGene = parse_factor(plotGene, levels = unique(plotGene))) %>%
  mutate(cellTypes = parse_factor(cellTypes, levels = c("A375-HOS", "HCT116-HOS", "A375-HCT116"))) %>%
  ggplot() +
  geom_tile(aes(type, plotGene, fill = log2(cpm + 1))) +
  facet_wrap(~cellTypes, scale = "free") +
  viridis::scale_fill_viridis() +
  theme_few() +
  theme(
    axis.text.x = element_text(angle = 90),
    axis.title.x = element_blank(),
    legend.position = "top"
  ) +
  labs(y = "Gene (Cell type)")
```

```{r, fig.align="center", fig.width=10, fig.height=8, message = FALSE}
p2 <- real %>% 
  inner_join(synth, by = c("gene", "cellTypes")) %>%
  gather(type, cpm, -gene, -(geneType:fold), -(cellTypes:cellType2)) %>%
  mutate(type = case_when(
    type == "Multiplet" ~ paste0(cellTypes, " multiplets"),
    type == "counts.x" ~ paste0(cellType1, " singlets"), 
    type == "counts.y" ~ paste0(cellType2, " singlets"),
    TRUE ~ type
  )) %>%
  mutate(type = parse_factor(type, levels = c(
    "A375-HCT116 multiplets", "A375-HOS multiplets", 
    "HCT116-HOS multiplets", "HOS reduced 0%", "HOS reduced 25%", 
    "HOS reduced 50%", "HOS reduced 75%", "HOS reduced 99%", 
    "A375 singlets", "HCT116 singlets", "HOS singlets"
  ))) %>%
  arrange(geneType, fold) %>%
  mutate(plotGene = paste0(gene, " (", geneType, ")")) %>%
  mutate(plotGene = parse_factor(plotGene, levels = unique(plotGene))) %>%
  mutate(cellTypes = parse_factor(cellTypes, levels = c("A375-HOS", "HCT116-HOS", "A375-HCT116"))) %>%
  ggplot() +
  geom_line(aes(type, log2(cpm + 1), group = gene, colour = geneType)) +
  geom_point(aes(type, log2(cpm + 1), colour = geneType), size = 0.75) +
  facet_wrap(~cellTypes, scales = "free") +
  labs(tag = "B)", y = "Mean log2(cpm + 1)", caption = paste0(
    "Expression of 25 cell type specific genes from each cell type in sorted ",
    "multiplets, synthetic multiplets (0%), adjusted synthetic multiplets ",
    "(25-99%), and singlets."
  )) +
  theme_bw() +
  ggthemes::scale_colour_ptol() +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_text(angle = 90),
    legend.position = "top"
  ) +
  guides(colour = guide_legend(
    title = "Gene's cell type specificity",
    title.position = "top", 
    title.hjust = 0.5)
  )

p2

ggsave(
  plot = p2,
  filename = '../figures/figure2.pdf',
  device = cairo_pdf,
  height = 180,
  width = 240,
  units = "mm"
)
```

The results show a minimal change in gene expression between the sorted 
multiplets and the non-adjusted (0%) multiplets (first two columns). In 
addition, the specificity of the genes for the individual cell types is easily
recognized (last two columns). Finally, it can be seen that decreasing levels
of HOS input into the synthetic multiplets causes a concomitatnt decrease in 
HOS specific gene expression in synthetic multiplets including the HOS cell 
type. On the other hand, in multiplets that do not include HOS cells, the gene 
expression of the HOS genes cause no changes in gene expression.

In summary, the results indicate that the algroithm for generating synthetic 
multiplets is capable of mirroring the gene expression profile in multiplets
of a known composition. Furthermore, adjusting the input of a specific cell type
in the multiplet results in the expected changes in the multiplets gene 
expression.
<br></br>

