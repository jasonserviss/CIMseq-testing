---
title: "Validation of synthetic data algorithm"
author: "Jason T. Serviss"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r, message = FALSE}
#PACKAGES
packages <- c(
  "sp.scRNAseq","sp.scRNAseqData", "sp.scRNAseqTesting",
  "seqTools", "printr", "ggthemes", "tidyverse"
)
purrr::walk(packages, library, character.only = TRUE)
rm(packages)

#FUNCTIONS
#cpm normalization withoit adding 1 that works on both matrices and tibbles with
#genes as rows and cells as columns
norm <- function(counts) {
  if(all(class(counts) == c("tbl_df", "tbl", "data.frame"))) {
    mat <- counts %>% 
      as.data.frame() %>%
      column_to_rownames("gene") %>%
      as.matrix()
    
    t(t(mat) / colSums(mat) * 10^6) %>%
      matrix_to_tibble("gene")
  } else if(class(counts) == "matrix") {
    t(t(counts) / colSums(counts) * 10^6)
  }
}
```

The synthetic multiplets are based on the mixing of real synthetic singlets. The 
algorithm for generating the synthetic multiplets works as follows: The sum of 
counts is calculated for each gene in two randomly selected singlets from 
each cell type contributing to the multiplet. The fraction of input into the 
multiplet can be adjusted so that, e.g. cell type A only contributes half of 
what cell type B contributes to the multiplet. A vector is then generated where 
each gene name is represented one time for each of the total counts (e.g. if 
gene "A" has a sum of counts from all singlets from the cell types 
contributing to the multiplet of 10, "A" will be repreated 10 times in the 
vector). This vector is then sampled without replacment. It is sampled x times, 
where x is equal to the sum of all the counts in all singlets contributing to 
the multiplet divided by the total number of singlets contributing to the 
multiplet. Gene names are then counted which provides the raw counts for the 
newly synthesized multiplet.

Here we utilize the sorted cell line dataset to generate multiplets from the 
singlets. The synthesized multiplets are then compared to the real multiplets
to acertain the quality of the _in silico_ synthesis. We begin by synthesizing 
one multiplet per cell line combination, i.e. a A375-HCT116, A375-HOS, and 
HCT116-HOS multiplet.

### Synthesize 10 multiplets per combination.

Here we continue to examine the ability of the synthesized multiplets to 
accuratley reflect the real multiplets by generating 10 multiplets per 
combination. It is hoped that this will show that the synthesized multiplets as
a whole, accuratley capture the diversity of the real multiplets.
```{r}
s <- str_detect(colnames(countsSorted2), "^s")
sng <- countsSorted2[, s]
classes <- slice(countsSortedMeta2, match(colnames(sng), countsSortedMeta2$sample))$cellTypes
combos <- apply(combn(unique(classes), 2), 2, sort)
adjustment <- rep(1, length(unique(classes)))
names(adjustment) <- unique(classes)

n <- 10
names <- paste(
  apply(combos, 2, paste, collapse = "-"), 
  rep(1:n, each = ncol(combos)), 
  sep = "."
)

synth <- sng %>%
  norm() %>%
  {map(1:n, function(x) {
    syntheticMultipletsFromCounts(., classes, combos, adjustment, seed = x + 9789)
  })} %>%
  reduce(full_join, by = "gene") %>%
  setNames(c("gene", names)) %>%
  norm()

mul <- countsSorted2[, !s] %>%
  norm() %>%
  matrix_to_tibble("gene") %>%
  gather(sample, counts, -gene) %>%
  left_join(countsSortedMeta2, by = "sample") %>%
  select(gene, counts, cellTypes, sample)
```

Plot results.

```{r, fig.align="center", fig.width=10, fig.height=8, message = FALSE}
synth %>% 
  gather(typeRep, synCounts, -gene) %>%
  separate(typeRep, c("cellTypes", "sample"), sep = "\\.") %>%
  inner_join(., mul, by = c("gene", "cellTypes")) %>% 
  gather(type, counts, -(gene:sample.x), -sample.y) %>%
  mutate(counts = log2(counts + 1)) %>%
  mutate(type = if_else(
    type == "counts", 
    "Real multiplets", 
    "Synthetic multiplets"
  )) %>%
  ggplot() + 
  geom_histogram(
    aes(counts, stat(ndensity), fill = type), 
    alpha = 0.5, binwidth = 0.25, position = "identity"
  ) +
  facet_wrap(~cellTypes) + 
  labs(x = "log2(Cpm)", y = "Density") +
  theme_bw() +
  ggthemes::scale_fill_ptol() +
  guides(fill = guide_legend(title = "")) +
  theme(legend.position = "top")
```

<br></br>

### Adjusting multiplet contribution

Synthesize 25 multiplets for each combination and reduce the contribution
of HOS cells by 0%, 25%, 50%, 75%, or 99%. Calculate the mean gene expression 
for each and plot together with the real multiplets and corresponding singlets.

```{r}
###FUNCTIONS
#function to calculate the mean gene expression for a specific cell type. Used 
#previous to heatmap plotting
typeMeans <- function(type) {
  countsSortedMeta2 %>%
  filter(cellTypes == type) %>% 
  pull(sample) %>%
  {countsSorted2[, colnames(countsSorted2) %in% .]} %>%
  norm() %>%
  rowMeans() %>%
  matrix_to_tibble("gene") %>%
  setNames(c("gene", "counts")) %>%
  mutate(cellType = type)
}

#wrapper to generate and reformat multiplets
generateAdjustedMultiplets <- function(sng, classes, combos, adjustment, name) {
  q.name <- enquo(name)
  sng %>%
    norm() %>%
    {map(1:n, function(x) {
      syntheticMultipletsFromCounts(., classes, combos, adjustment, seed = x + 9789)
    })} %>%
    reduce(full_join, by = "gene") %>%
    setNames(c("gene", names)) %>%
    norm() %>%
    gather(cellTypes, !!q.name, -gene) %>%
    mutate(cellTypes = str_replace(cellTypes, "(.*)\\..*", "\\1")) %>%
    group_by(gene, cellTypes) %>%
    summarize(!! quo_name(q.name) := mean(!!q.name)) %>%
    ungroup()
}
###

#Synthesize multiplets with varying levels of adjusted HOS input
s <- str_detect(colnames(countsSorted2), "^s")
sng <- countsSorted2[, s]
classes <- slice(countsSortedMeta2, match(colnames(sng), countsSortedMeta2$sample))$cellTypes
combos <- apply(combn(unique(classes), 2), 2, sort)

adjustment <- rep(1, length(unique(classes)))
names(adjustment) <- unique(classes)
n <- 25
names <- paste(
  apply(combos, 2, paste, collapse = "-"), 
  rep(1:n, each = ncol(combos)), 
  sep = "."
)

adj <- c(1, 0.75, 0.5, 0.25, 0.01)
synth <- map(adj, function(x) {
  adjustment[names(adjustment) == "HOS"] <- x
  generateAdjustedMultiplets(sng, classes, combos, adjustment, synCounts)
}) %>%
  reduce(inner_join, by = c("gene", "cellTypes")) %>%
  setNames(c("gene", "cellTypes", paste0("HOS reduced ", (1 - adj) * 100, "%")))

#heatmap
#find overexpressed genes in each cell type
genes <- foldChangePerClass(cpm(sng), rename(countsSortedMeta2, class = cellTypes)) %>%
  matrix_to_tibble("gene") %>%
  select(gene, A375, HCT116, HOS) %>%
  gather(cellType, fold, -gene) %>%
  group_by(cellType) %>%
  top_n(25, fold) %>%
  ungroup()

#calculate the mean gene expression for each type of singlet
realSng <- map_dfr(c("A375", "HCT116", "HOS"), typeMeans)

#calculate the mean gene expression for each type of multiplet
#concatenate real singlet, real multiplet, and info for genes corresponding to 
#a cell type

real <- map_dfr(c("A375-HCT116", "A375-HOS", "HCT116-HOS"), typeMeans) %>%
  rename(Multiplet = counts, cellTypes = cellType) %>% 
  separate(cellTypes, into = c("cellType1", "cellType2"), sep = "-", remove = FALSE) %>%
  inner_join(realSng, by = c("cellType1" = "cellType", "gene" = "gene")) %>% 
  inner_join(realSng, by = c("cellType2" = "cellType", "gene" = "gene")) %>%
  inner_join(genes, by = "gene") %>%
  filter(cellType == cellType1 | cellType == cellType2) %>%
  rename(geneType = cellType)
```

```{r, eval = FALSE}
#join everything and plot
real %>% 
  inner_join(synth, by = c("gene", "cellTypes")) %>%
  gather(type, cpm, -gene, -(geneType:fold), -(cellTypes:cellType2)) %>%
  mutate(type = case_when(
    type == "counts.x" ~ cellType1, 
    type == "counts.y" ~ cellType2, 
    TRUE ~ type
  )) %>%
  mutate(type = parse_factor(type, levels = c(
      "Multiplet", "HOS reduced 0%", "HOS reduced 25%", "HOS reduced 50%", "HOS reduced 75%", "HOS reduced 99%", "A375", "HCT116", "HOS"
  ))) %>%
  arrange(geneType, fold) %>%
  mutate(plotGene = paste0(gene, " (", geneType, ")")) %>%
  mutate(plotGene = parse_factor(plotGene, levels = unique(plotGene))) %>%
  mutate(cellTypes = parse_factor(cellTypes, levels = c("A375-HOS", "HCT116-HOS", "A375-HCT116"))) %>%
  ggplot() +
  geom_tile(aes(type, plotGene, fill = log2(cpm + 1))) +
  facet_wrap(~cellTypes, scale = "free") +
  viridis::scale_fill_viridis() +
  theme_few() +
  theme(
    axis.text.x = element_text(angle = 90),
    axis.title.x = element_blank(),
    legend.position = "top"
  ) +
  labs(y = "Gene (Cell type)")
```

```{r, fig.align="center", fig.width=10, fig.height=8, message = FALSE}
real %>% 
  inner_join(synth, by = c("gene", "cellTypes")) %>%
  gather(type, cpm, -gene, -(geneType:fold), -(cellTypes:cellType2)) %>%
  mutate(type = case_when(
    type == "Multiplet" ~ paste0(cellTypes, " multiplets mean"),
    type == "counts.x" ~ paste0(cellType1, " singlets mean"), 
    type == "counts.y" ~ paste0(cellType2, " singlets mean"),
    TRUE ~ type
  )) %>%
  mutate(type = parse_factor(type, levels = c(
    "A375-HCT116 multiplets mean", "A375-HOS multiplets mean", 
    "HCT116-HOS multiplets mean", "HOS reduced 0%", "HOS reduced 25%", 
    "HOS reduced 50%", "HOS reduced 75%", "HOS reduced 99%", 
    "A375 singlets mean", "HCT116 singlets mean", "HOS singlets mean"
  ))) %>%
  arrange(geneType, fold) %>%
  mutate(plotGene = paste0(gene, " (", geneType, ")")) %>%
  mutate(plotGene = parse_factor(plotGene, levels = unique(plotGene))) %>%
  mutate(cellTypes = parse_factor(cellTypes, levels = c("A375-HOS", "HCT116-HOS", "A375-HCT116"))) %>%
  ggplot() +
  geom_line(aes(type, log2(cpm + 1), group = gene, colour = geneType)) +
  geom_point(aes(type, log2(cpm + 1), colour = geneType)) +
  facet_wrap(~cellTypes, scales = "free") +
  theme_bw() +
  ggthemes::scale_colour_ptol() +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_text(angle = 90),
    legend.position = "top"
  ) +
  guides(colour = guide_legend(
    title = "Gene's cell type specificity",
    title.position = "top", 
    title.hjust = 0.5)
  )
```

<br></br>

