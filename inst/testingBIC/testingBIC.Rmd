---
title: "Testing BIC as a distance function."
author: "Jason T. Serviss"
date: "13/07/2017"
output:
  html_document:
    code_folding: hide
    highlight: pygments
    theme: readable
---

```{r loadLibraries, message=FALSE, warning = FALSE}
packages <- c(
    "mesenchymalAnalysis",
    "sp.scRNAseq",
    "sp.scRNAseqTesting",
    "printr",
    "ggthemes",
    "tidyverse",
    "stringr",
    "viridis"
)
purrr::walk(packages, library, character.only = TRUE)
rm(packages)
options(digits = 2)
```

Run using the "large" data set to characterize singlets and the BIC distance function to identify connections in the multiplets.
```{r setup}
#import data and setup the spCounts objects
tsne <- my.tsne.2d.full.top2000.log
counts <- counts.nodups
s <- grepl("^s", colnames(expCounts))
multiplets <- expCounts[ ,!s]

counts <- counts[rownames(counts) %in% rownames(multiplets), ]
multiplets <- multiplets[rownames(multiplets) %in% rownames(counts), ]

cObjSng <- spCounts(counts, matrix(1, ncol=ncol(counts)))
cObjMul <- spCounts(multiplets, expErcc[, !s])

#run spUnsupervised and replace with the precomputed tsne and classifications
uObj <- spUnsupervised(cObjSng, max_iter = 5, Gmax = 3)
tsne <- my.tsne.2d.full.top2000.log
tsne(uObj) <- tsne
tsneMeans(uObj) <- tsneGroupMeans(tsne, sampleClasses$class)
groupMeans(uObj) <- averageGroupExpression(cObjSng, sampleClasses$class, FALSE)
classification(uObj) <- sampleClasses$class
uncertainty(uObj) <- rep(0, nrow(sampleClasses))
selectInd(uObj) <- spTopMax(cObjSng, 2000)
uObjBic <- uObj
```

```{r, eval = FALSE}
#run spSwarm 
sObjBic <- spSwarm(cObjMul, uObj, swarmsize = 500, cores = 6, maxiter = 1000, distFun = bic, report = TRUE, reportRate = 10)
save(uObjBic, sObjBic, file = "~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic.rda", compress = "bzip2")
```

```{r, echo = FALSE}
load("~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic.rda")
```

Plot the swarm positions at 10, 500, and 1000 (the final) iterations.
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
#plot the swarm progress for non-self edges
allEdges <- spSwarmPoisson(sObjBic, edge.cutoff = 0, min.pval = 1, min.num.edges = 1)
nselfEdges <- filter(allEdges, from != to)

multsInEdges <- getMultipletsForEdge(sObjBic, 0, as.data.frame(nselfEdges[, 1:2]))
plotSwarmPosition(sObjBic, unlist(multsInEdges), c(1,50,100))
```

Plot the detected connections.
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
#show the swarm plots
#plotSwarm(sObjBic, uObjBic, cObjSng, type="tsne", edge.cutoff = 0, min.num.edges = 1, min.pval = 0.05)
plotSwarm(sObjBic, type = "edgeBar", edge.cutoff = 0, min.num.edges = 1)
```

The detected connections look much more realistic. Many of the connections are expected due to the fact that they represent known ongoing differentiation processes (Endocrine progenitor -> Beta, Ductal -> Acinar, Ductal -> Endocrine Progenitor). In addition 37 of the edges (or `r paste(round(100*(37/sum(allEdges$weight)), digits = 2), "%", sep = "")` of the total detected edges) are endothelial - endothelial connections which makes sense due to the fact that multiplets were sorted on this marker. The number of self connections in the multiplets is `r sum(filter(allEdges, from == to)$weight)` or `r paste(round(100 * (sum(filter(allEdges, from == to)$weight) / sum(allEdges$weight)), digits = 2), "%", sep = "")` of the total edges. A table below shows the non-self connections, their weights and p-values (although the p-value calculation needs some improvment).

```{r}
nselfEdges
```

Each multiplet is giving rise to 1 edge. This could mean that the BIC method is giving rise to some false negatives, i.e. is too strict.
```{r}
#edgForMul <- getEdgesForMultiplet(sObjBic, edge.cutoff = 0, rownames(getData(sObjBic, "spSwarm")))
#table(edgForMul$multiplet)
```

In addition we can run the synthetic dataset using the BIC distance calculation.
```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
#real <- as.data.frame(syntheticDataTable) #note that this is going to detect multiple self connections in examples like: m.C1C1B1B1 whereas the swarm is only going to detect a C1-B1 connection
#try to re-write function that calculates the real connections (calculateConnections)

funx <- function(swarm, edge.cutoff = 0) {
    
    #outputs a list with the individual cell types included per multiplet
    input <- map(rownames(swarm), str_count, pattern = colnames(swarm)) %>%
        do.call(rbind, .) %>%
        t() %>%
        as.data.frame() %>%
        map(., function(x) colnames(swarm)[x > 0]) %>%
        setNames(rownames(swarm))
    
    #finds all connections per multiplet
    lapply(1:length(input), function(x) {
        y <- input[[x]]
        if(length(y) > 1) {
            co <- combn(y, 2)
            colnames(co) <- rep(names(input)[x], ncol(co))
            co
        } else {
            matrix(rep(y, 2), ncol = 1, dimnames = list(NULL, names(input)[x]))
        }
    }) %>%
        do.call(cbind, .) %>%
        t() %>%
        data.frame(., rowname = rownames(.), row.names = 1:nrow(.)) %>%
        as_tibble() %>%
        mutate(
            from = as.character(pull(., X1)), 
            to = as.character(pull(., X2)), 
            multiplet = as.character(pull(., rowname))
        ) %>%
        select(multiplet, from, to)
}

funx(swarm = getData(syntheticDataSwarm, "spSwarm"), edge.cutoff = 0) %>%
    mutate(real = paste(from, to, sep = "-")) %>%
    select(-from, -to) %>%
    left_join(getEdgesForMultiplet(syntheticDataSwarm, 1/10.5, rownames(getData(syntheticDataSwarm, "spSwarm"))), by = "multiplet") %>%
    mutate(detected = paste(from, to, sep = "-")) %>%
    select(-from, -to) %>%
    gather(type, connection, -multiplet) %>%
    group_by(connection, type) %>%
    summarize(count = n()) %>%
    ungroup() %>%
    ggplot(., aes(type, connection)) +
    geom_tile(aes(fill = count)) +
    facet_grid(
        .~type,
        space = "free",
        scale = "free",
        labeller = as_labeller(c(
            `detected` = "Detected",
            `real` = "Real"
        ))
    ) +
    scale_fill_viridis() +
    theme_few() +
    labs(
        x = "Type",
        y = "Connection"
    ) +
    guides(fill = guide_colorbar(title = "Count")) +
    theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        strip.text.x = element_text()
    )
    
```

The results show that the algorithm is correctly classifying all multiplets. It should be noted, however, that when multiplets include both self and non-self connections, only the non-self connections are detected.

We can also try another "test strategy". If we divide the classified cell types into multiple groups and re-run the swarm optimization, we should ideally see many connections arise between the groups. To get an idea if this works, we can start by subdividing one of the cell types (Acinar) with a large number of cells in the dataset.
```{r}
subClasses <- tsne %>%
    as.data.frame() %>%
    rownames_to_column() %>%
    as_tibble() %>%
    dplyr::rename(sample = rowname, tsneDim1 = V1, tsneDim2 = V2) %>%
    left_join(sampleClasses) %>%
    mutate(subClass = case_when(
        class == "Acinar" & tsneDim1 < -34.9 ~ "Acinar-1",
        class == "Acinar" & tsneDim1 >= -34.9 & tsneDim1 < -29.8 ~ "Acinar-2",
        class == "Acinar" & tsneDim1 >= -29.8 & tsneDim1 < -24.7 ~ "Acinar-3",
        class == "Acinar" & tsneDim1 >= -24.7 & tsneDim1 < -19.6 ~ "Acinar-4",
        class == "Acinar" & tsneDim1 >= -19.6 & tsneDim1 < -14.5 ~ "Acinar-5",
        class == "Acinar" & tsneDim1 >= -14.5 & tsneDim1 < -9.4 ~ "Acinar-6",
        class == "Acinar" & tsneDim1 >= -9.4 & tsneDim1 < -4.3 ~ "Acinar-7",
        class == "Acinar" & tsneDim1 >= -4.3 & tsneDim1 < -0.8 ~ "Acinar-8",
        class == "Acinar" & tsneDim1 >= -0.8 & tsneDim1 < 5.9 ~ "Acinar-9",
        class == "Acinar" & tsneDim1 >= 5.9 & tsneDim1 < 11.1 ~ "Acinar-10",
        class != "Acinar" ~ class,
        TRUE ~ "error"
    ))

#tsne %>%
#    as.data.frame() %>%
#    rownames_to_column() %>%
#    rename(sample = rowname, tsneDim1 = V1, tsneDim2 = V2) %>%
#    as_tibble() %>%
#    left_join(sampleClasses) %>%
#    mutate(subClass = case_when(
#        class == "Endothelial" & tsneDim1 < -92.1 ~ "Acinar-1",
#        class == "Endothelial" & tsneDim1 >= -92.1 & tsneDim1 < -91.2 ~ "Acinar-2",
#        class == "Endothelial" & tsneDim1 >= -91.2 & tsneDim1 < -90.3 ~ "Acinar-3",
#        class == "Endothelial" & tsneDim1 >= -90.3 & tsneDim1 < -89.4 ~ "Acinar-4",
#        class == "Endothelial" & tsneDim1 >= -89.4 & tsneDim1 < -88.5 ~ "Acinar-5",
#        class == "Endothelial" & tsneDim1 >= -88.5 & tsneDim1 < -87.6 ~ "Acinar-6",
#        class == "Endothelial" & tsneDim1 >= -87.6 & tsneDim1 < -86.7 ~ "Acinar-7",
#        class == "Endothelial" & tsneDim1 >= -86.7 & tsneDim1 < -85.8 ~ "Acinar-8",
#        class == "Endothelial" & tsneDim1 >= -85.8 & tsneDim1 < -84.9 ~ "Acinar-9",
#        class == "Endothelial" & tsneDim1 >= -84.9 & tsneDim1 < -84 ~ "Acinar-10",
#        class != "Endothelial" ~ class,
#        TRUE ~ "error"
#    ))

#run spUnsupervised and replace with the precomputed tsne and classifications
uObj <- spUnsupervised(cObjSng, max_iter = 5, Gmax = 3)
tsne <- my.tsne.2d.full.top2000.log
tsne(uObj) <- tsne
tsneMeans(uObj) <- tsneGroupMeans(tsne, subClasses$subClass)
groupMeans(uObj) <- averageGroupExpression(cObjSng, subClasses$subClass, FALSE)
classification(uObj) <- subClasses$subClass
uncertainty(uObj) <- rep(0, nrow(sampleClasses))
selectInd(uObj) <- spTopMax(cObjSng, 2000)
uObjBic2 <- uObj
```

```{r, eval = FALSE}
sObjBic2 <- spSwarm(cObjMul, uObjBic2, swarmsize = 500, cores = 6, maxiter = 1000, distFun = bic, report = TRUE, reportRate = 10)
save(sObjBic2, file = "~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic2.rda", compress = "bzip2")
```

```{r, echo = FALSE}
load("~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic2.rda")
```

```{r, fig.align='center', fig.height=8, fig.width=10, eval=TRUE, message=FALSE}
plotUnsupervised(uObjBic2)
plotSwarm(sObjBic2, type = "edgeBar", edge.cutoff = 0, min.num.edges = 1)

```

The results in fact do indicate that we detect many connections within the acinar subgroup as would be expected.

```{r, eval = FALSE}
sObjBic3 <- spSwarm(cObjSng, uObjBic, swarmsize = 500, cores = 6, maxiter = 1000, distFun = bic, report = FALSE, reportRate = 10)
save(sObjBic3, file = "~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic3.rda", compress = "bzip2")
```

```{r, echo = FALSE}
load("~/Github/sp.scRNAseqTesting/inst/testingBIC/sObjBic3.rda")
```

```{r, fig.align='center', fig.height=12, fig.width=10, eval=TRUE, message=FALSE}
classification <- getData(uObjBic, "classification") %>%
    as_tibble() %>%
    add_column(sample = rownames(getData(uObjBic, "tsne"))) %>%
    dplyr::rename(classification = value)

spSwarmPoisson(sObjBic3, 0) %>%
    filter(weight > 0) %>%
    select(1, 2) %>%
    getMultipletsForEdge(sObjBic3, 0, .) %>%
    left_join(classification, by = c("multiplet" = "sample")) %>%
    select(from, to, classification) %>%
    table() %>%
    as_tibble() %>%
    filter(n > 0) %>%
    mutate(detected = case_when(
        from == classification & to == classification ~ classification,
        from == classification & to != classification ~ to,
        from != classification & to == classification ~ from,
        TRUE ~ paste(from, to, sep = "- ")
    )) %>%
    ggplot(., aes(classification, detected)) +
    geom_tile(aes(fill = n)) +
    theme_few() +
    scale_fill_viridis() +
    theme(
        axis.text.x = element_text(angle = 90)
    ) +
    labs(
        x = "Classification (by Mclust)",
        y = "Detected classification or connection"
    ) +
    guides(fill = guide_colorbar(title = "Count"))

```

The results indicate that many of the singlets are mis-classified. This could be compounded by the fact that an uncertainty parameter and weighted means are not included in the analysis although this seems like it would actually make the problem worse. In some cases this can be explained by the following: In cases where 2 groups of singlets are close to one another (acinar and ductal for example), since we use the mean of the groups in the deconvolution, it can be the case that an individual singlet (acinar), when running the deconvolution on the singlets, is closer to the mean of the "other" group (ductal) than it is to the mean of its "own" group (acinar). In theory this could be happening with doublets as well and therefore, the implications should be considered further.

Finally, we can look at the performance of the BIC distance function on the expression dataset (where singlets were combined into multiplets).
```{r, fig.align='center', fig.height=12, fig.width=10, eval=TRUE, message=FALSE}
funx(swarm = getData(expressionTestSwarm, "spSwarm"), edge.cutoff = 0) %>%
    mutate(real = paste(from, to, sep = "-")) %>%
    select(-from, -to) %>%
    left_join(
        getEdgesForMultiplet(
            expressionTestSwarm, 
            1/9.5, 
            rownames(getData(expressionTestSwarm, "spSwarm"))
        ), 
        by = "multiplet"
    ) %>%
    mutate(detected = paste(from, to, sep = "-")) %>%
    select(-from, -to) %>%
    gather(type, connection, -multiplet) %>%
    group_by(connection, type) %>%
    summarize(count = n()) %>%
    ungroup() %>%
    ggplot(., aes(type, connection)) +
    geom_tile(aes(fill = count)) +
    facet_grid(
        .~type,
        space = "free",
        scale = "free",
        labeller = as_labeller(c(
            `detected` = "Detected",
            `real` = "Real"
        ))
    ) +
    scale_fill_viridis() +
    theme_few() +
    labs(
        x = "Type",
        y = "Connection"
    ) +
    guides(fill = guide_colorbar(title = "Count")) +
    theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        strip.text.x = element_text()
    )

```

The results indicate that, in the same manner as the synthetic dataset, the BIC distance function characterizes all multiplets correctly. 

In summary, the BIC distance function seems to be performing better than the previously used distToSlice function although the evidence for this is minimal. Both distance functions were able to acuratley identify all connections in the multiplets in the synthetic and expression datasets. Although the "subgroups test" (where a known cell type is divided into multiple cell types) was never performed with the distToSlice funciton, it would be expected to perform well there as well. Thus, the main evidence that the BIC distance function has an increased performance compared to the distToSlice function is its results using the real data, the reasons for this belief being outlined in the respective results. 







